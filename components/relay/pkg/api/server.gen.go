// Code generated by oto; DO NOT EDIT.

package api

import (
	"context"
	"log"
	"net/http"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"

	"github.com/pacedotdev/oto/otohttp"
)

var (
	relayBanTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_ban_total",
		Help: "Auto-generated metric incremented on every call to Relay.Ban",
	})
	relayBanSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_ban_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Ban that does not return with an error",
	})

	relayBlockTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_block_total",
		Help: "Auto-generated metric incremented on every call to Relay.Block",
	})
	relayBlockSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_block_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Block that does not return with an error",
	})

	relayCreateChannelTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_create_channel_total",
		Help: "Auto-generated metric incremented on every call to Relay.CreateChannel",
	})
	relayCreateChannelSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_create_channel_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.CreateChannel that does not return with an error",
	})

	relayDeleteChannelTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_delete_channel_total",
		Help: "Auto-generated metric incremented on every call to Relay.DeleteChannel",
	})
	relayDeleteChannelSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_delete_channel_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.DeleteChannel that does not return with an error",
	})

	relayDeleteMessageTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_delete_message_total",
		Help: "Auto-generated metric incremented on every call to Relay.DeleteMessage",
	})
	relayDeleteMessageSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_delete_message_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.DeleteMessage that does not return with an error",
	})

	relayJoinTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_join_total",
		Help: "Auto-generated metric incremented on every call to Relay.Join",
	})
	relayJoinSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_join_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Join that does not return with an error",
	})

	relayKickTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_kick_total",
		Help: "Auto-generated metric incremented on every call to Relay.Kick",
	})
	relayKickSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_kick_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Kick that does not return with an error",
	})

	relayLeaveTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_leave_total",
		Help: "Auto-generated metric incremented on every call to Relay.Leave",
	})
	relayLeaveSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_leave_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Leave that does not return with an error",
	})

	relayUnbanTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_unban_total",
		Help: "Auto-generated metric incremented on every call to Relay.Unban",
	})
	relayUnbanSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_unban_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Unban that does not return with an error",
	})

	relayUnblockTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_unblock_total",
		Help: "Auto-generated metric incremented on every call to Relay.Unblock",
	})
	relayUnblockSuccessTotal = promauto.NewCounter(prometheus.CounterOpts{
		Name: "relay_unblock_success_total",
		Help: "Auto-generated metric incremented on every call to Relay.Unblock that does not return with an error",
	})
)

type Relay interface {
	Ban(context.Context, BanRequest) (*BanResponse, error)
	Block(context.Context, BlockRequest) (*BlockResponse, error)
	CreateChannel(context.Context, CreateChannelRequest) (*CreateChannelResponse, error)
	DeleteChannel(context.Context, DeleteChannelRequest) (*DeleteChannelResponse, error)
	DeleteMessage(context.Context, DeleteMessageRequest) (*DeleteMessageResponse, error)
	Join(context.Context, JoinRequest) (*JoinResponse, error)
	Kick(context.Context, KickRequest) (*KickResponse, error)
	Leave(context.Context, LeaveRequest) (*LeaveResponse, error)
	Unban(context.Context, UnbanRequest) (*UnbanResponse, error)
	Unblock(context.Context, UnblockRequest) (*UnblockResponse, error)
}

type relayServer struct {
	server *otohttp.Server
	relay  Relay
}

func RegisterRelay(server *otohttp.Server, relay Relay) {
	handler := &relayServer{
		server: server,
		relay:  relay,
	}
	server.Register("Relay", "Ban", handler.handleBan)
	server.Register("Relay", "Block", handler.handleBlock)
	server.Register("Relay", "CreateChannel", handler.handleCreateChannel)
	server.Register("Relay", "DeleteChannel", handler.handleDeleteChannel)
	server.Register("Relay", "DeleteMessage", handler.handleDeleteMessage)
	server.Register("Relay", "Join", handler.handleJoin)
	server.Register("Relay", "Kick", handler.handleKick)
	server.Register("Relay", "Leave", handler.handleLeave)
	server.Register("Relay", "Unban", handler.handleUnban)
	server.Register("Relay", "Unblock", handler.handleUnblock)
}

func (s *relayServer) handleBan(w http.ResponseWriter, r *http.Request) {
	relayBanTotal.Inc()
	var request BanRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Ban(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayBanSuccessTotal.Inc()
}

func (s *relayServer) handleBlock(w http.ResponseWriter, r *http.Request) {
	relayBlockTotal.Inc()
	var request BlockRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Block(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayBlockSuccessTotal.Inc()
}

func (s *relayServer) handleCreateChannel(w http.ResponseWriter, r *http.Request) {
	relayCreateChannelTotal.Inc()
	var request CreateChannelRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.CreateChannel(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayCreateChannelSuccessTotal.Inc()
}

func (s *relayServer) handleDeleteChannel(w http.ResponseWriter, r *http.Request) {
	relayDeleteChannelTotal.Inc()
	var request DeleteChannelRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.DeleteChannel(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayDeleteChannelSuccessTotal.Inc()
}

func (s *relayServer) handleDeleteMessage(w http.ResponseWriter, r *http.Request) {
	relayDeleteMessageTotal.Inc()
	var request DeleteMessageRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.DeleteMessage(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayDeleteMessageSuccessTotal.Inc()
}

func (s *relayServer) handleJoin(w http.ResponseWriter, r *http.Request) {
	relayJoinTotal.Inc()
	var request JoinRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Join(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayJoinSuccessTotal.Inc()
}

func (s *relayServer) handleKick(w http.ResponseWriter, r *http.Request) {
	relayKickTotal.Inc()
	var request KickRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Kick(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayKickSuccessTotal.Inc()
}

func (s *relayServer) handleLeave(w http.ResponseWriter, r *http.Request) {
	relayLeaveTotal.Inc()
	var request LeaveRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Leave(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayLeaveSuccessTotal.Inc()
}

func (s *relayServer) handleUnban(w http.ResponseWriter, r *http.Request) {
	relayUnbanTotal.Inc()
	var request UnbanRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Unban(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayUnbanSuccessTotal.Inc()
}

func (s *relayServer) handleUnblock(w http.ResponseWriter, r *http.Request) {
	relayUnblockTotal.Inc()
	var request UnblockRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.relay.Unblock(r.Context(), request)
	if err != nil {
		log.Println("TODO: oto service error:", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	relayUnblockSuccessTotal.Inc()
}

type BanRequest struct {
	UserID string `json:"userID"`
	ChatID string `json:"chatID"`
}

type BanResponse struct {
	Error string `json:"error,omitempty"`
}

type BlockRequest struct {
	UserID string `json:"userID"`
}

type BlockResponse struct {
	Error string `json:"error,omitempty"`
}

type CreateChannelRequest struct {
	IsChannel bool `json:"isChannel"`
}

type CreateChannelResponse struct {
	ID    string `json:"id"`
	Error string `json:"error,omitempty"`
}

type DeleteChannelRequest struct {
	ID string `json:"id"`
}

type DeleteChannelResponse struct {
	Error string `json:"error,omitempty"`
}

type DeleteMessageRequest struct {
	ID string `json:"id"`
}

type DeleteMessageResponse struct {
	Error string `json:"error,omitempty"`
}

type JoinRequest struct {
	UserID string `json:"userID"`
	ChatID string `json:"chatID"`
}

type JoinResponse struct {
	Error string `json:"error,omitempty"`
}

type KickRequest struct {
	UserID string `json:"userID"`
}

type KickResponse struct {
	Error string `json:"error,omitempty"`
}

type LeaveRequest struct {
	UserID string `json:"userID"`
	ChatID string `json:"chatID"`
}

type LeaveResponse struct {
	Error string `json:"error,omitempty"`
}

type UnbanRequest struct {
	UserID string `json:"userID"`
	ChatID string `json:"chatID"`
}

type UnbanResponse struct {
	Error string `json:"error,omitempty"`
}

type UnblockRequest struct {
	UserID string `json:"userID"`
}

type UnblockResponse struct {
	Error string `json:"error,omitempty"`
}
